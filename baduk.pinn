#define SIZER 3;
#define SIZEC 2;
#define BSIZE SIZER SIZEC *;
#define HASHT 3 BSIZE ^;
#define BTOT BSIZE HASHT *;

E := 0;
B := 1;
W := 2;
N := 3;
X := 4;
I := 5;
TRUE := 1;
FALSE := 0;
_counter := 0;

var bd [BTOT]int;
var bh [HASHT]int;

func move (player, x, y int) int {
  push();
  bd[hrc(hsize - 1, x, y)] = player;
  cap(opposite(player), x + 1, y);
  cap(opposite(player), x - 1, y);
  cap(opposite(player), x, y + 1);
  cap(opposite(player), x, y - 1);
  cap(player, x, y);
  return sko();
}

func cmp(a, b int) int {
  var r, c int;
  for r = range 0:SIZER {
    for c = range 0:SIZEC {
      if bd[hrc(a, r, c)] != bd[hrc(b, r, c)] {
        return FALSE;
      }
    }
  }
  return TRUE;
}

func ok() int {
  var x int;
  for x = range 0:hsize - 1 {
    if cmp(x, hsize - 1) == TRUE {
      return FALSE;
    }
  }
  return TRUE;
}

func hash() int {
  rt := 0;
  var r, c, hc int;
  var da, db int;
  for r = range 0:SIZER {
    for c = range 0:SIZEC {
      rt = rt * 3;
      da = dbg();
      hc = hrc(hsize - 1, r, c); 
      db = dbg();
      assert(da, db);
      rt = rt + bd[hc];
    }
  }
  return rt;

}
func sko() int {
  h := hash();
  if bh[h] == 1 {
  //return ok();
  //if ok() == FALSE { 
    hsize--;
    return FALSE;
  //}
  }
  bh[h] = 1;
  return TRUE;
}

func mark (player, x, y int) int {
  var da int;
  var rt int;
  //da = dbg();
  if x < 0 || x >= SIZER || y < 0 || y >= SIZEC || cp[rc(x, y)] == opposite(player) || cp[rc(x, y)] == I {
    return FALSE;
  }
  if cp[rc(x, y)] == E {
    return TRUE;
  }
  cp[rc(x, y)] = I;
  rt = FALSE;
  if mark(player, x + 1, y) == TRUE { rt = TRUE; }
  if mark(player, x - 1, y) == TRUE { rt = TRUE; }
  if mark(player, x, y + 1) == TRUE { rt = TRUE; }

  if mark(player, x, y - 1) == TRUE { rt = TRUE; }
  //_db = dbg();
  //assert(da, _db);
  return rt;
}

func cap (player int, x, y int) {

  if x < 0 || x >= SIZER || y < 0 || y >= SIZEC {
    return;
  }
  var r, c int;
  copy2cp();
  rt := mark(player, x, y);
  if rt == TRUE {
    return;
  }
  for r = range 0:SIZER {
    for c = range 0:SIZEC {
      if cp[rc(r, c)] == I {
        cp[rc(r, c)] = E;
      }
    }
  }
  copy2bd();
}
var cp [BSIZE] int;
func copy2bd() {
  var x int;
  var y int;
  for x = range 0:SIZER {
    for y = range 0:SIZEC {
      bd[hrc(hsize - 1, x, y)] = cp[rc(x, y)];
    }
  }
}

func push() {
  hsize++;
  var x int;
  var y int;
  for x = range 0:SIZER {
    for y = range 0:SIZEC {
      bd[hrc(hsize - 1, x, y)] = bd[hrc(hsize - 2, x, y)];
    }
  }
}

func copy2cp() {
  var x int;
  var y int;
  var da, db, dd int;
  for x = range 0:SIZER {
    for y = range 0:SIZEC {
      da = dbg(); 
      dd = bd[hrc(hsize - 1, x, y)];
      db = dbg();
      assert(da, db);
      cp[rc(x, y)] = dd;

    }
  }
}

func score (h int) int {
    b := 0;
    w := 0;
    var cs int;
    var da, db int;
    copy2cp();
    var x, y, p int;
    for x = range 0:SIZER {
        for y = range 0:SIZEC {
            if bd[hrc(h, x, y)] == B {b++;} else
            if bd[hrc(h, x, y)] == W {w++;} else
            {
              p = N;
                  da = dbg();
                  cs, p = color(p, x, y, 0);
                  db = dbg();
                  assert(da, db);
                  if p == B b += cs;
                  if p == W w += cs;
            }
            
        }
    }
    return b - w;
}

func mscore(player int) int {
  return player == B ? score(hsize - 1) : -score(hsize - 1);
}

func color (p, x, y, score int) int, int {
    if x < 0 || x >= SIZER || y < 0 || y >= SIZEC || cp[rc(x, y)] == I {
      return score, p;
    }
    pin := cp[rc(x, y)];
    if pin == E {
      cp[rc(x,y)] = I;
      score++;
      score, p = color(p, x + 1, y, score);
      score, p = color(p, x - 1, y, score);
      score, p = color(p, x, y + 1, score);
      score, p = color(p, x, y - 1, score);
    } else if p == N {
      p = pin;
    } else if p != pin {
      p = X;
    }
    return score, p;
}

func rc (r, c int) int {
  return r * SIZEC  + c;
}
func hrc (h, r, c int) int {
  return  rc(r, c);
}

func opposite (opx int) int { 
 return opx == B ? W : B;
}

func printAll() {
  var x int;
  for x = range 0:hsize {
    println();
    print(x);
    printBoard(x);
  }
}

func printBoard (i index) {
  println();
  printchar("^^^");
  println();
  var y int;
  var x int;
  for x = range 0:SIZER {
    for y = range 0:SIZEC {
        print (bd[hrc(i, x, y)]);
    }
        println();
  }
  println();
  s := score(i);
  print(np(s));
  printchar("---");
  println();
}

hsize := 1;

bh[hash()] = 1;


hsize++;

//bd[hrc(1, 0, 0)] = W;
//bh[hash()] = 1;

sc := minimax(B, FALSE);
print(np(sc));


func minimax (player int, passed int) int
{
  if _counter % 100 == 0 {
    printBoard(hsize - 1);
    println();
  }
  var da, db int;
  _counter++;
  var best int;
  if passed == TRUE {
          da = dbg();
    best = mscore(player);
          db = dbg();
          assert(da, db);
  } else {
          da = dbg();
    best = -minimax(opposite(player), TRUE);
          db = dbg();
          assert(da, db);
  }
  if best == BSIZE {
    return best;
  }

  var s, r, c, b  int;
  for r = range 0:SIZER {
    for c = range 0:SIZEC {
      if bd[hrc(hsize - 1, r, c)] == E {
        b = move(player, r, c);
        if b == TRUE {
          da = dbg();
          s = -minimax(opposite(player), FALSE);
          db = dbg();
          assert(da, db);
          if s > best {
            best = s;
          }
          bh[hash()] = 0;
          hsize--;
          if best == BSIZE {
            return best;
          }
        }
      }
    }
  }
  return best;
}

func np(a int) int {
  if a < 0 { printchar("-"); return -a; }
  return a;
}

