#define BSIZE 3
#define HIST 0x100
#define BTOT 0x1000

E := 0;
B := 1;
SIZEC := 3;
W := 2;
N := 3;
X := 4;
I := 5;
SIZER := 1;
TRUE := 1;
FALSE := 0;
_counter := 0;

func move (player, x, y int) int {
  push();
  bd[hrc(hsize - 1, x, y)] = player;
  cap(opposite(player), x + 1, y);
  cap(opposite(player), x - 1, y);
  cap(opposite(player), x, y + 1);
  cap(opposite(player), x, y - 1);
  cap(player, x, y);
  if sko() == FALSE {
    return FALSE;
  }
  return TRUE;
}

func hash() int {
  rt := 0;
  var r, c int;
  for r = range 0:SIZER {
    for c = range 0:SIZEC {
      rt = rt * 3;
      rt = rt + bd[hrc(hsize - 1, r, c)];
    }
  }
  return rt;

}

func isSame(h2, h1 int) int {
  var r, c int;
  for r = range 0:SIZER {
    for c = range 0:SIZEC {
      if bd[hrc(h1, r, c)] != bd[hrc(h2, r, c)] {
        return FALSE;
      }
    }
  }
  return TRUE;
}

func sko () int {
  h := hash();
  if bh[h] == 1 {
    hsize--;
    return FALSE;
  }
  bh[h] = 1;
  return TRUE;
}

func mark (player, x, y int) int {
    if x < 0 || x >= SIZER || y < 0 || y >= SIZEC {
      return FALSE;
    }
  if cp[rc(x, y)] == E {
    return TRUE;
  }
  if cp[rc(x, y)] == player {
    cp[rc(x, y)] = I;
  } else {
    return FALSE;
  }
  rt := FALSE;
  if mark(player, x + 1, y) == TRUE { rt = TRUE; }
  if mark(player, x - 1, y) == TRUE { rt = TRUE; }
  if mark(player, x, y + 1) == TRUE { rt = TRUE; }
  if mark(player, x, y - 1) == TRUE { rt = TRUE; }
  return rt;
}

func cap (player int, x, y int) {

    if x < 0 || x >= SIZER || y < 0 || y >= SIZEC {
      return;
    }
  var r, c int;
  copy2cp();
  rt := mark(player, x, y);
  if rt == TRUE {
    return;
  }
  for r = range 0:SIZER {
    for c = range 0:SIZEC {
      if cp[rc(r, c)] == I {
        cp[rc(r, c)] = E;
      }
    }
  }
  copy2bd();
}

var cp [BSIZE] int;
func copy2bd() {
  var x int;
  var y int;
  for x = range 0:SIZER {
    for y = range 0:SIZEC {
      bd[hrc(hsize - 1, x, y)] = cp[rc(x, y)];
    }
  }
}

func push() {
  hsize++;
  var x int;
  var y int;
  for x = range 0:SIZER {
    for y = range 0:SIZEC {
      bd[hrc(hsize - 1, x, y)] = bd[hrc(hsize - 2, x, y)];
    }
  }
}

func copy2cp() {
  var x int;
  var y int;
  for x = range 0:SIZER {
    for y = range 0:SIZEC {
      cp[rc(x, y)] = bd[hrc(hsize - 1, x, y)];
    }
  }
}

func score (h int) int {
    b := 0;
    w := 0;
    var cs int;
    copy2cp();
    var x, y int;
    for x = range 0:SIZER {
        for y = range 0:SIZEC {
            if bd[hrc(h, x, y)] == B {b++;} else
            if bd[hrc(h, x, y)] == W {w++;} else
            {
              _player = N;
                  cs = color(x, y, 0);
                  if _player == B b += cs;
                  if _player == W w += cs;
            }
            
        }
    }
    return b - w;
}

func mscore(player int) int {
  return player == B ? score(hsize - 1) : -score(hsize - 1);
}

var _player int;
func color (x, y, score int) int {


    if x < 0 || x >= SIZER || y < 0 || y >= SIZEC || cp[rc(x, y)] == I {
      return score;
    }
    mscore := score;
    pin := cp[rc(x, y)];
    if pin == E {
      cp[rc(x,y)] = I;
      mscore++;
      mscore = color(x + 1, y, score);
      mscore = color(x - 1, y, score);
      mscore = color(x, y + 1, score);
      mscore = color(x, y - 1, score);
    } else if _player == N {
      _player = pin;
    } else if _player != pin {
      _player = X;
    }
    return mscore;
}

func rc (r, c int) int {
  rcr := r * SIZEC  + c;
  return rcr;

}
func hrc (h, r, c int) int {
  if h >= HIST {
  printchar("bad");
  bad();
  }
  return h * BSIZE + rc(r, c);
}

func opposite (opx int) int { 
 return opx == B ? W : B;
}

func printAll() {
  var x int;
  for x = range 0:hsize {
    println();
    print(x);
    printBoard(x);
  }
}

func printBoard (i index) {
println();
  var y int;
  var x int;
  for x = range 0:SIZER {
    for y = range 0:SIZEC {
        print (bd[hrc(i, x, y)]);
    }
        println();
  }
  println();
  printchar("---");
  println();
}

hsize := 1;
var bd [BTOT]int;



var bh [81]int;
bh[hash()] = 1;
//hsize++;
//bd[hrc(1, 0, 0)] = W;
//bh[hash()] = 1;




sc := minimax(B, FALSE);
print(np(sc));








func minimax (player int, passed int) int
{
if _counter % 1000000 == 0 {
  print(hsize);
  println();
}
_counter++;
  var best int;
  if passed == TRUE {
    best = mscore(player);
  } else {
    best = -minimax(opposite(player), TRUE);
  }

  var s, r, c, b  int;
  for r = range 0:SIZER {
    for c = range 0:SIZEC {
      if bd[hrc(hsize - 1, r, c)] == E {
        b = move(player, r, c);
        if b == TRUE {

          s = -minimax(opposite(player), FALSE);
          if s > best {
            best = s;
          }
          bh[hash()] = 0;
          hsize--;
        }
      }
    }
  }
  return best;
}

func np(a int) int {
  if a < 0 { printchar("-"); return -a; }
  return a;
}
